/* Copyright (c) 2023, Canaan Bright Sight Co., Ltd
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/input.h>
#include <unistd.h>
#include <sys/select.h>

static void sleep_ms(unsigned int ms)
{
	struct timeval tval;
	
	tval.tv_sec = ms / 1000;
	tval.tv_usec = (ms * 1000) % 1000000;
	select(0, NULL, NULL, NULL, &tval);
}


/* ws2812	24bit GRB 
-------------------------------------
|	8bit G	|	8bit R	|	8bit B	|
-------------------------------------

*/

/* 测试使用灯条共33个ws2812灯珠 */
// green
static unsigned char color1[] = { 0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0, \
	0xff, 0x0, 0x0
};

// blue
static unsigned char color2[] = { 0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff, \
	0x0, 0x0, 0xff
};

// red
static unsigned char color3[] = { 0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0, \
	0x0, 0xff, 0x0
};

static unsigned char grb_color[] = {
	0x00, 0xff, 0x00,
	0xff, 0x00, 0x00,
	0x00, 0x00, 0xff,
	0x00, 0xff, 0x00,
	0xff, 0x00, 0x00,
	0x00, 0x00, 0xff,
	0x00, 0x8b, 0x00,
	0x00, 0xcd, 0x00,
	0x00, 0xef, 0x00,
	0x00, 0xff, 0x00,
	0x45, 0x8b, 0x00,
	0x66, 0xcd, 0x00,
	0x76, 0xee, 0x00,
	0x7f, 0xff, 0x00,
	0x7e, 0x8b, 0x66,
	0xba, 0xcd, 0x96,
	0xd8, 0xee, 0xae,
	0xe7, 0xff, 0xba,
	0x47, 0x8b, 0x26,
	0x68, 0xcd, 0x39,
	0x79, 0xee, 0x42,
	0x82, 0xff, 0x47,
	0x95, 0xcd, 0x0c,
	0xad, 0xee, 0x0e,
	0xb9, 0xff, 0x0f,
	0xad, 0xcd, 0x00,
	0xc9, 0xee, 0x00,
	0xd7, 0xff, 0x00,
	0xcd, 0xcd, 0x00,
	0xee, 0xee, 0x00,
	0xff, 0xff, 0x00,
	0xee, 0x76, 0x00,
	0xff, 0x7f, 0x00,
};

/* 33个灯，每个灯24bit */
static unsigned char light[99] = { 0x0 };

int main(int argc, char *argv[])
{
	int fd;
	int i = 0;
	int m = 33;
	int n;

    fd = open("/dev/ws2812", O_RDWR);
	if(fd<=0)
	{
        printf("open ws2812 device error!\n");
		return 0;
	}

#if 0
	/* 多彩色 */
	write(fd, grb_color, sizeof(grb_color));

	/* 闪烁 */
	write(fd, color1, sizeof(color1));
	sleep(1);
	write(fd, color2, sizeof(color2));
	sleep(1);
	write(fd, color3, sizeof(color3));
	sleep(1);
	write(fd, color1, sizeof(color1));
	sleep_ms(50);
	write(fd, color2, sizeof(color2));
	sleep_ms(50);
	write(fd, color3, sizeof(color3));
	sleep_ms(50);
	write(fd, color1, sizeof(color1));
	sleep_ms(50);
	write(fd, color2, sizeof(color2));
	sleep_ms(50);
	write(fd, color3, sizeof(color3));
	sleep_ms(50);
	write(fd, color1, sizeof(color1));
	sleep_ms(50);
	write(fd, color2, sizeof(color2));
	sleep_ms(50);
	write(fd, color3, sizeof(color3));
	sleep_ms(50);
	write(fd, color1, sizeof(color1));
	sleep_ms(50);
	write(fd, color2, sizeof(color2));
	sleep_ms(50);
	write(fd, color3, sizeof(color3));
	sleep_ms(50);
	write(fd, color1, sizeof(color1));
	sleep_ms(50);
	write(fd, color2, sizeof(color2));
	sleep_ms(50);
	write(fd, color3, sizeof(color3));
	sleep_ms(50);
	write(fd, color1, sizeof(color1));
	sleep_ms(50);
	write(fd, color2, sizeof(color2));
	sleep_ms(50);
	write(fd, color3, sizeof(color3));
	sleep_ms(50);
#endif

#if 0
	/* 流水灯 */
	while (1)
	{
		for (i = 0; i < m; i++)
		{
			write(fd, light, sizeof(light));

			light[i*3 + 2] = 0xff;
			if (i > 0)
				light[(i-1)*3 +2] = 0x0;
			sleep_ms(50);
		}
		m --;
		if (m < 0)
		{
			light[2] = 0xff;
			write(fd, light, sizeof(light));
			break;
		}
	}

	memset(light, 0, sizeof(light));
	write(fd, light, sizeof(light));
#endif

#if 1
	/* 呼吸灯 */
	while(1)
	{
		for (n = 0; n < 0xff; n++)
		{
			for (i = 0; i < m; i++)
			{
				light[i*3] = n;	//g
			}
			write(fd, light, sizeof(light));
			sleep_ms(5);
		}

		for (n = 0xff; n >= 0; n--)
		{
			for (i = 0; i < m; i++)
			{
				light[i*3] = n;	//g
			}
			write(fd, light, sizeof(light));
			sleep_ms(5);
		}

		for (n = 0; n < 0xff; n++)
		{
			for (i = 0; i < m; i++)
			{
				light[i*3 + 1] = n;	//r
			}
			write(fd, light, sizeof(light));
			sleep_ms(5);
		}

		for (n = 0xff; n >= 0; n--)
		{
			for (i = 0; i < m; i++)
			{
				light[i*3 + 1] = n;	//r
			}
			write(fd, light, sizeof(light));
			sleep_ms(5);
		}

		for (n = 0; n < 0xff; n++)
		{
			for (i = 0; i < m; i++)
			{
				light[i*3 + 2] = n;	//b
			}
			write(fd, light, sizeof(light));
			sleep_ms(5);
		}

		for (n = 0xff; n >= 0; n--)
		{
			for (i = 0; i < m; i++)
			{
				light[i*3 + 2] = n;	//b
			}
			write(fd, light, sizeof(light));
			sleep_ms(5);
		}
	}
#endif

	return 0;
}

